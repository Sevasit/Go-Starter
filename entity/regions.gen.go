// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package entity

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/Sevasit/go-crud/model"
)

func newRegion(db *gorm.DB, opts ...gen.DOOption) region {
	_region := region{}

	_region.regionDo.UseDB(db, opts...)
	_region.regionDo.UseModel(&model.Region{})

	tableName := _region.regionDo.TableName()
	_region.ALL = field.NewAsterisk(tableName)
	_region.RegionID = field.NewInt32(tableName, "region_id")
	_region.RegionName = field.NewString(tableName, "region_name")

	_region.fillFieldMap()

	return _region
}

type region struct {
	regionDo

	ALL        field.Asterisk
	RegionID   field.Int32
	RegionName field.String

	fieldMap map[string]field.Expr
}

func (r region) Table(newTableName string) *region {
	r.regionDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r region) As(alias string) *region {
	r.regionDo.DO = *(r.regionDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *region) updateTableName(table string) *region {
	r.ALL = field.NewAsterisk(table)
	r.RegionID = field.NewInt32(table, "region_id")
	r.RegionName = field.NewString(table, "region_name")

	r.fillFieldMap()

	return r
}

func (r *region) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *region) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 2)
	r.fieldMap["region_id"] = r.RegionID
	r.fieldMap["region_name"] = r.RegionName
}

func (r region) clone(db *gorm.DB) region {
	r.regionDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r region) replaceDB(db *gorm.DB) region {
	r.regionDo.ReplaceDB(db)
	return r
}

type regionDo struct{ gen.DO }

type IRegionDo interface {
	gen.SubQuery
	Debug() IRegionDo
	WithContext(ctx context.Context) IRegionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRegionDo
	WriteDB() IRegionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IRegionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IRegionDo
	Not(conds ...gen.Condition) IRegionDo
	Or(conds ...gen.Condition) IRegionDo
	Select(conds ...field.Expr) IRegionDo
	Where(conds ...gen.Condition) IRegionDo
	Order(conds ...field.Expr) IRegionDo
	Distinct(cols ...field.Expr) IRegionDo
	Omit(cols ...field.Expr) IRegionDo
	Join(table schema.Tabler, on ...field.Expr) IRegionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRegionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRegionDo
	Group(cols ...field.Expr) IRegionDo
	Having(conds ...gen.Condition) IRegionDo
	Limit(limit int) IRegionDo
	Offset(offset int) IRegionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IRegionDo
	Unscoped() IRegionDo
	Create(values ...*model.Region) error
	CreateInBatches(values []*model.Region, batchSize int) error
	Save(values ...*model.Region) error
	First() (*model.Region, error)
	Take() (*model.Region, error)
	Last() (*model.Region, error)
	Find() ([]*model.Region, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Region, err error)
	FindInBatches(result *[]*model.Region, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Region) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IRegionDo
	Assign(attrs ...field.AssignExpr) IRegionDo
	Joins(fields ...field.RelationField) IRegionDo
	Preload(fields ...field.RelationField) IRegionDo
	FirstOrInit() (*model.Region, error)
	FirstOrCreate() (*model.Region, error)
	FindByPage(offset int, limit int) (result []*model.Region, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRegionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r regionDo) Debug() IRegionDo {
	return r.withDO(r.DO.Debug())
}

func (r regionDo) WithContext(ctx context.Context) IRegionDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r regionDo) ReadDB() IRegionDo {
	return r.Clauses(dbresolver.Read)
}

func (r regionDo) WriteDB() IRegionDo {
	return r.Clauses(dbresolver.Write)
}

func (r regionDo) Session(config *gorm.Session) IRegionDo {
	return r.withDO(r.DO.Session(config))
}

func (r regionDo) Clauses(conds ...clause.Expression) IRegionDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r regionDo) Returning(value interface{}, columns ...string) IRegionDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r regionDo) Not(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r regionDo) Or(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r regionDo) Select(conds ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r regionDo) Where(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r regionDo) Order(conds ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r regionDo) Distinct(cols ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r regionDo) Omit(cols ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r regionDo) Join(table schema.Tabler, on ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r regionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRegionDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r regionDo) RightJoin(table schema.Tabler, on ...field.Expr) IRegionDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r regionDo) Group(cols ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r regionDo) Having(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r regionDo) Limit(limit int) IRegionDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r regionDo) Offset(offset int) IRegionDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r regionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IRegionDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r regionDo) Unscoped() IRegionDo {
	return r.withDO(r.DO.Unscoped())
}

func (r regionDo) Create(values ...*model.Region) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r regionDo) CreateInBatches(values []*model.Region, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r regionDo) Save(values ...*model.Region) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r regionDo) First() (*model.Region, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) Take() (*model.Region, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) Last() (*model.Region, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) Find() ([]*model.Region, error) {
	result, err := r.DO.Find()
	return result.([]*model.Region), err
}

func (r regionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Region, err error) {
	buf := make([]*model.Region, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r regionDo) FindInBatches(result *[]*model.Region, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r regionDo) Attrs(attrs ...field.AssignExpr) IRegionDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r regionDo) Assign(attrs ...field.AssignExpr) IRegionDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r regionDo) Joins(fields ...field.RelationField) IRegionDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r regionDo) Preload(fields ...field.RelationField) IRegionDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r regionDo) FirstOrInit() (*model.Region, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) FirstOrCreate() (*model.Region, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) FindByPage(offset int, limit int) (result []*model.Region, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r regionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r regionDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r regionDo) Delete(models ...*model.Region) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *regionDo) withDO(do gen.Dao) *regionDo {
	r.DO = *do.(*gen.DO)
	return r
}
